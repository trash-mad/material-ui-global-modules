"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertArrayExpression = assertArrayExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertFile = assertFile;
exports.assertForInStatement = assertForInStatement;
exports.assertForStatement = assertForStatement;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertStringLiteral = assertStringLiteral;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertNullLiteral = assertNullLiteral;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertMemberExpression = assertMemberExpression;
exports.assertNewExpression = assertNewExpression;
exports.assertProgram = assertProgram;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectProperty = assertObjectProperty;
exports.assertRestElement = assertRestElement;
exports.assertReturnStatement = assertReturnStatement;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertThisExpression = assertThisExpression;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTryStatement = assertTryStatement;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertClassBody = assertClassBody;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertClassExpression = assertClassExpression;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertForOfStatement = assertForOfStatement;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertMetaProperty = assertMetaProperty;
exports.assertClassMethod = assertClassMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSuper = assertSuper;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertYieldExpression = assertYieldExpression;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertClassImplements = assertClassImplements;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXText = assertJSXText;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertNoop = assertNoop;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertBindExpression = assertBindExpression;
exports.assertClassProperty = assertClassProperty;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertImport = assertImport;
exports.assertDecorator = assertDecorator;
exports.assertDoExpression = assertDoExpression;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertPrivateName = assertPrivateName;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSRestType = assertTSRestType;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSImportType = assertTSImportType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertExpression = assertExpression;
exports.assertBinary = assertBinary;
exports.assertScopable = assertScopable;
exports.assertBlockParent = assertBlockParent;
exports.assertBlock = assertBlock;
exports.assertStatement = assertStatement;
exports.assertTerminatorless = assertTerminatorless;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertLoop = assertLoop;
exports.assertWhile = assertWhile;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFor = assertFor;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionParent = assertFunctionParent;
exports.assertPureish = assertPureish;
exports.assertDeclaration = assertDeclaration;
exports.assertPatternLike = assertPatternLike;
exports.assertLVal = assertLVal;
exports.assertTSEntityName = assertTSEntityName;
exports.assertLiteral = assertLiteral;
exports.assertImmutable = assertImmutable;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertMethod = assertMethod;
exports.assertObjectMember = assertObjectMember;
exports.assertProperty = assertProperty;
exports.assertUnaryLike = assertUnaryLike;
exports.assertPattern = assertPattern;
exports.assertClass = assertClass;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertFlow = assertFlow;
exports.assertFlowType = assertFlowType;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertJSX = assertJSX;
exports.assertPrivate = assertPrivate;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSType = assertTSType;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestProperty = assertRestProperty;
exports.assertSpreadProperty = assertSpreadProperty;

var _is = _interopRequireDefault(require("../../validators/is"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", but instead got \"" + node.type + "\".");
  }
}

function assertArrayExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ArrayExpression", node, opts);
}

function assertAssignmentExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("AssignmentExpression", node, opts);
}

function assertBinaryExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BinaryExpression", node, opts);
}

function assertInterpreterDirective(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("InterpreterDirective", node, opts);
}

function assertDirective(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Directive", node, opts);
}

function assertDirectiveLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DirectiveLiteral", node, opts);
}

function assertBlockStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BlockStatement", node, opts);
}

function assertBreakStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BreakStatement", node, opts);
}

function assertCallExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("CallExpression", node, opts);
}

function assertCatchClause(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("CatchClause", node, opts);
}

function assertConditionalExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ConditionalExpression", node, opts);
}

function assertContinueStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ContinueStatement", node, opts);
}

function assertDebuggerStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DebuggerStatement", node, opts);
}

function assertDoWhileStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DoWhileStatement", node, opts);
}

function assertEmptyStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("EmptyStatement", node, opts);
}

function assertExpressionStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExpressionStatement", node, opts);
}

function assertFile(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("File", node, opts);
}

function assertForInStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ForInStatement", node, opts);
}

function assertForStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ForStatement", node, opts);
}

function assertFunctionDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FunctionDeclaration", node, opts);
}

function assertFunctionExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FunctionExpression", node, opts);
}

function assertIdentifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Identifier", node, opts);
}

function assertIfStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("IfStatement", node, opts);
}

function assertLabeledStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("LabeledStatement", node, opts);
}

function assertStringLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("StringLiteral", node, opts);
}

function assertNumericLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("NumericLiteral", node, opts);
}

function assertNullLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("NullLiteral", node, opts);
}

function assertBooleanLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BooleanLiteral", node, opts);
}

function assertRegExpLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("RegExpLiteral", node, opts);
}

function assertLogicalExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("LogicalExpression", node, opts);
}

function assertMemberExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("MemberExpression", node, opts);
}

function assertNewExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("NewExpression", node, opts);
}

function assertProgram(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Program", node, opts);
}

function assertObjectExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectExpression", node, opts);
}

function assertObjectMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectMethod", node, opts);
}

function assertObjectProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectProperty", node, opts);
}

function assertRestElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("RestElement", node, opts);
}

function assertReturnStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ReturnStatement", node, opts);
}

function assertSequenceExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("SequenceExpression", node, opts);
}

function assertSwitchCase(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("SwitchCase", node, opts);
}

function assertSwitchStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("SwitchStatement", node, opts);
}

function assertThisExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ThisExpression", node, opts);
}

function assertThrowStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ThrowStatement", node, opts);
}

function assertTryStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TryStatement", node, opts);
}

function assertUnaryExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("UnaryExpression", node, opts);
}

function assertUpdateExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("UpdateExpression", node, opts);
}

function assertVariableDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("VariableDeclaration", node, opts);
}

function assertVariableDeclarator(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("VariableDeclarator", node, opts);
}

function assertWhileStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("WhileStatement", node, opts);
}

function assertWithStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("WithStatement", node, opts);
}

function assertAssignmentPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("AssignmentPattern", node, opts);
}

function assertArrayPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ArrayPattern", node, opts);
}

function assertArrowFunctionExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ArrowFunctionExpression", node, opts);
}

function assertClassBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassBody", node, opts);
}

function assertClassDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassDeclaration", node, opts);
}

function assertClassExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassExpression", node, opts);
}

function assertExportAllDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExportAllDeclaration", node, opts);
}

function assertExportDefaultDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExportDefaultDeclaration", node, opts);
}

function assertExportNamedDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExportNamedDeclaration", node, opts);
}

function assertExportSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExportSpecifier", node, opts);
}

function assertForOfStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ForOfStatement", node, opts);
}

function assertImportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ImportDeclaration", node, opts);
}

function assertImportDefaultSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ImportDefaultSpecifier", node, opts);
}

function assertImportNamespaceSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ImportNamespaceSpecifier", node, opts);
}

function assertImportSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ImportSpecifier", node, opts);
}

function assertMetaProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("MetaProperty", node, opts);
}

function assertClassMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassMethod", node, opts);
}

function assertObjectPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectPattern", node, opts);
}

function assertSpreadElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("SpreadElement", node, opts);
}

function assertSuper(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Super", node, opts);
}

function assertTaggedTemplateExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TaggedTemplateExpression", node, opts);
}

function assertTemplateElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TemplateElement", node, opts);
}

function assertTemplateLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TemplateLiteral", node, opts);
}

function assertYieldExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("YieldExpression", node, opts);
}

function assertAnyTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("AnyTypeAnnotation", node, opts);
}

function assertArrayTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ArrayTypeAnnotation", node, opts);
}

function assertBooleanTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BooleanTypeAnnotation", node, opts);
}

function assertBooleanLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BooleanLiteralTypeAnnotation", node, opts);
}

function assertNullLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("NullLiteralTypeAnnotation", node, opts);
}

function assertClassImplements(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassImplements", node, opts);
}

function assertDeclareClass(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareClass", node, opts);
}

function assertDeclareFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareFunction", node, opts);
}

function assertDeclareInterface(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareInterface", node, opts);
}

function assertDeclareModule(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareModule", node, opts);
}

function assertDeclareModuleExports(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareModuleExports", node, opts);
}

function assertDeclareTypeAlias(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareTypeAlias", node, opts);
}

function assertDeclareOpaqueType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareOpaqueType", node, opts);
}

function assertDeclareVariable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareVariable", node, opts);
}

function assertDeclareExportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareExportDeclaration", node, opts);
}

function assertDeclareExportAllDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclareExportAllDeclaration", node, opts);
}

function assertDeclaredPredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DeclaredPredicate", node, opts);
}

function assertExistsTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExistsTypeAnnotation", node, opts);
}

function assertFunctionTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FunctionTypeAnnotation", node, opts);
}

function assertFunctionTypeParam(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FunctionTypeParam", node, opts);
}

function assertGenericTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("GenericTypeAnnotation", node, opts);
}

function assertInferredPredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("InferredPredicate", node, opts);
}

function assertInterfaceExtends(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("InterfaceExtends", node, opts);
}

function assertInterfaceDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("InterfaceDeclaration", node, opts);
}

function assertInterfaceTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("InterfaceTypeAnnotation", node, opts);
}

function assertIntersectionTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("IntersectionTypeAnnotation", node, opts);
}

function assertMixedTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("MixedTypeAnnotation", node, opts);
}

function assertEmptyTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("EmptyTypeAnnotation", node, opts);
}

function assertNullableTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("NullableTypeAnnotation", node, opts);
}

function assertNumberLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("NumberLiteralTypeAnnotation", node, opts);
}

function assertNumberTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("NumberTypeAnnotation", node, opts);
}

function assertObjectTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectTypeAnnotation", node, opts);
}

function assertObjectTypeInternalSlot(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectTypeInternalSlot", node, opts);
}

function assertObjectTypeCallProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectTypeCallProperty", node, opts);
}

function assertObjectTypeIndexer(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectTypeIndexer", node, opts);
}

function assertObjectTypeProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectTypeProperty", node, opts);
}

function assertObjectTypeSpreadProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectTypeSpreadProperty", node, opts);
}

function assertOpaqueType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("OpaqueType", node, opts);
}

function assertQualifiedTypeIdentifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("QualifiedTypeIdentifier", node, opts);
}

function assertStringLiteralTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("StringLiteralTypeAnnotation", node, opts);
}

function assertStringTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("StringTypeAnnotation", node, opts);
}

function assertThisTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ThisTypeAnnotation", node, opts);
}

function assertTupleTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TupleTypeAnnotation", node, opts);
}

function assertTypeofTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TypeofTypeAnnotation", node, opts);
}

function assertTypeAlias(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TypeAlias", node, opts);
}

function assertTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TypeAnnotation", node, opts);
}

function assertTypeCastExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TypeCastExpression", node, opts);
}

function assertTypeParameter(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TypeParameter", node, opts);
}

function assertTypeParameterDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TypeParameterDeclaration", node, opts);
}

function assertTypeParameterInstantiation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TypeParameterInstantiation", node, opts);
}

function assertUnionTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("UnionTypeAnnotation", node, opts);
}

function assertVariance(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Variance", node, opts);
}

function assertVoidTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("VoidTypeAnnotation", node, opts);
}

function assertJSXAttribute(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXAttribute", node, opts);
}

function assertJSXClosingElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXClosingElement", node, opts);
}

function assertJSXElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXElement", node, opts);
}

function assertJSXEmptyExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXEmptyExpression", node, opts);
}

function assertJSXExpressionContainer(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXExpressionContainer", node, opts);
}

function assertJSXSpreadChild(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXSpreadChild", node, opts);
}

function assertJSXIdentifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXIdentifier", node, opts);
}

function assertJSXMemberExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXMemberExpression", node, opts);
}

function assertJSXNamespacedName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXNamespacedName", node, opts);
}

function assertJSXOpeningElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXOpeningElement", node, opts);
}

function assertJSXSpreadAttribute(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXSpreadAttribute", node, opts);
}

function assertJSXText(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXText", node, opts);
}

function assertJSXFragment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXFragment", node, opts);
}

function assertJSXOpeningFragment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXOpeningFragment", node, opts);
}

function assertJSXClosingFragment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSXClosingFragment", node, opts);
}

function assertNoop(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Noop", node, opts);
}

function assertParenthesizedExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ParenthesizedExpression", node, opts);
}

function assertAwaitExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("AwaitExpression", node, opts);
}

function assertBindExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BindExpression", node, opts);
}

function assertClassProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassProperty", node, opts);
}

function assertOptionalMemberExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("OptionalMemberExpression", node, opts);
}

function assertPipelineTopicExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("PipelineTopicExpression", node, opts);
}

function assertPipelineBareFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("PipelineBareFunction", node, opts);
}

function assertPipelinePrimaryTopicReference(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("PipelinePrimaryTopicReference", node, opts);
}

function assertOptionalCallExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("OptionalCallExpression", node, opts);
}

function assertClassPrivateProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassPrivateProperty", node, opts);
}

function assertClassPrivateMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ClassPrivateMethod", node, opts);
}

function assertImport(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Import", node, opts);
}

function assertDecorator(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Decorator", node, opts);
}

function assertDoExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("DoExpression", node, opts);
}

function assertExportDefaultSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExportDefaultSpecifier", node, opts);
}

function assertExportNamespaceSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExportNamespaceSpecifier", node, opts);
}

function assertPrivateName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("PrivateName", node, opts);
}

function assertBigIntLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BigIntLiteral", node, opts);
}

function assertTSParameterProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSParameterProperty", node, opts);
}

function assertTSDeclareFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSDeclareFunction", node, opts);
}

function assertTSDeclareMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSDeclareMethod", node, opts);
}

function assertTSQualifiedName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSQualifiedName", node, opts);
}

function assertTSCallSignatureDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSCallSignatureDeclaration", node, opts);
}

function assertTSConstructSignatureDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSConstructSignatureDeclaration", node, opts);
}

function assertTSPropertySignature(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSPropertySignature", node, opts);
}

function assertTSMethodSignature(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSMethodSignature", node, opts);
}

function assertTSIndexSignature(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSIndexSignature", node, opts);
}

function assertTSAnyKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSAnyKeyword", node, opts);
}

function assertTSUnknownKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSUnknownKeyword", node, opts);
}

function assertTSNumberKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSNumberKeyword", node, opts);
}

function assertTSObjectKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSObjectKeyword", node, opts);
}

function assertTSBooleanKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSBooleanKeyword", node, opts);
}

function assertTSStringKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSStringKeyword", node, opts);
}

function assertTSSymbolKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSSymbolKeyword", node, opts);
}

function assertTSVoidKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSVoidKeyword", node, opts);
}

function assertTSUndefinedKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSUndefinedKeyword", node, opts);
}

function assertTSNullKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSNullKeyword", node, opts);
}

function assertTSNeverKeyword(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSNeverKeyword", node, opts);
}

function assertTSThisType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSThisType", node, opts);
}

function assertTSFunctionType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSFunctionType", node, opts);
}

function assertTSConstructorType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSConstructorType", node, opts);
}

function assertTSTypeReference(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeReference", node, opts);
}

function assertTSTypePredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypePredicate", node, opts);
}

function assertTSTypeQuery(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeQuery", node, opts);
}

function assertTSTypeLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeLiteral", node, opts);
}

function assertTSArrayType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSArrayType", node, opts);
}

function assertTSTupleType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTupleType", node, opts);
}

function assertTSOptionalType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSOptionalType", node, opts);
}

function assertTSRestType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSRestType", node, opts);
}

function assertTSUnionType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSUnionType", node, opts);
}

function assertTSIntersectionType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSIntersectionType", node, opts);
}

function assertTSConditionalType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSConditionalType", node, opts);
}

function assertTSInferType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSInferType", node, opts);
}

function assertTSParenthesizedType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSParenthesizedType", node, opts);
}

function assertTSTypeOperator(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeOperator", node, opts);
}

function assertTSIndexedAccessType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSIndexedAccessType", node, opts);
}

function assertTSMappedType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSMappedType", node, opts);
}

function assertTSLiteralType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSLiteralType", node, opts);
}

function assertTSExpressionWithTypeArguments(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSExpressionWithTypeArguments", node, opts);
}

function assertTSInterfaceDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSInterfaceDeclaration", node, opts);
}

function assertTSInterfaceBody(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSInterfaceBody", node, opts);
}

function assertTSTypeAliasDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeAliasDeclaration", node, opts);
}

function assertTSAsExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSAsExpression", node, opts);
}

function assertTSTypeAssertion(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeAssertion", node, opts);
}

function assertTSEnumDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSEnumDeclaration", node, opts);
}

function assertTSEnumMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSEnumMember", node, opts);
}

function assertTSModuleDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSModuleDeclaration", node, opts);
}

function assertTSModuleBlock(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSModuleBlock", node, opts);
}

function assertTSImportType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSImportType", node, opts);
}

function assertTSImportEqualsDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSImportEqualsDeclaration", node, opts);
}

function assertTSExternalModuleReference(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSExternalModuleReference", node, opts);
}

function assertTSNonNullExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSNonNullExpression", node, opts);
}

function assertTSExportAssignment(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSExportAssignment", node, opts);
}

function assertTSNamespaceExportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSNamespaceExportDeclaration", node, opts);
}

function assertTSTypeAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeAnnotation", node, opts);
}

function assertTSTypeParameterInstantiation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeParameterInstantiation", node, opts);
}

function assertTSTypeParameterDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeParameterDeclaration", node, opts);
}

function assertTSTypeParameter(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeParameter", node, opts);
}

function assertExpression(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Expression", node, opts);
}

function assertBinary(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Binary", node, opts);
}

function assertScopable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Scopable", node, opts);
}

function assertBlockParent(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("BlockParent", node, opts);
}

function assertBlock(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Block", node, opts);
}

function assertStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Statement", node, opts);
}

function assertTerminatorless(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Terminatorless", node, opts);
}

function assertCompletionStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("CompletionStatement", node, opts);
}

function assertConditional(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Conditional", node, opts);
}

function assertLoop(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Loop", node, opts);
}

function assertWhile(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("While", node, opts);
}

function assertExpressionWrapper(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExpressionWrapper", node, opts);
}

function assertFor(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("For", node, opts);
}

function assertForXStatement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ForXStatement", node, opts);
}

function assertFunction(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Function", node, opts);
}

function assertFunctionParent(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FunctionParent", node, opts);
}

function assertPureish(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Pureish", node, opts);
}

function assertDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Declaration", node, opts);
}

function assertPatternLike(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("PatternLike", node, opts);
}

function assertLVal(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("LVal", node, opts);
}

function assertTSEntityName(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSEntityName", node, opts);
}

function assertLiteral(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Literal", node, opts);
}

function assertImmutable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Immutable", node, opts);
}

function assertUserWhitespacable(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("UserWhitespacable", node, opts);
}

function assertMethod(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Method", node, opts);
}

function assertObjectMember(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ObjectMember", node, opts);
}

function assertProperty(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Property", node, opts);
}

function assertUnaryLike(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("UnaryLike", node, opts);
}

function assertPattern(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Pattern", node, opts);
}

function assertClass(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Class", node, opts);
}

function assertModuleDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ModuleDeclaration", node, opts);
}

function assertExportDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ExportDeclaration", node, opts);
}

function assertModuleSpecifier(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("ModuleSpecifier", node, opts);
}

function assertFlow(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Flow", node, opts);
}

function assertFlowType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FlowType", node, opts);
}

function assertFlowBaseAnnotation(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FlowBaseAnnotation", node, opts);
}

function assertFlowDeclaration(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FlowDeclaration", node, opts);
}

function assertFlowPredicate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("FlowPredicate", node, opts);
}

function assertJSX(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("JSX", node, opts);
}

function assertPrivate(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("Private", node, opts);
}

function assertTSTypeElement(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSTypeElement", node, opts);
}

function assertTSType(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  assert("TSType", node, opts);
}

function assertNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  assert("NumberLiteral", node, opts);
}

function assertRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}

function assertRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}

function assertSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  assert("SpreadProperty", node, opts);
}