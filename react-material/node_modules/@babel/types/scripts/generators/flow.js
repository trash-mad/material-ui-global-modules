"use strict";

var t = require("../../");
var stringifyValidator = require("../utils/stringifyValidator");
var toFunctionName = require("../utils/toFunctionName");

var NODE_PREFIX = "BabelNode";

var code = "// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/flow.js for script used.\n\ndeclare class " + NODE_PREFIX + "Comment {\n  value: string;\n  start: number;\n  end: number;\n  loc: " + NODE_PREFIX + "SourceLocation;\n}\n\ndeclare class " + NODE_PREFIX + "CommentBlock extends " + NODE_PREFIX + "Comment {\n  type: \"CommentBlock\";\n}\n\ndeclare class " + NODE_PREFIX + "CommentLine extends " + NODE_PREFIX + "Comment {\n  type: \"CommentLine\";\n}\n\ndeclare class " + NODE_PREFIX + "SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ndeclare class " + NODE_PREFIX + " {\n  leadingComments?: Array<" + NODE_PREFIX + "Comment>;\n  innerComments?: Array<" + NODE_PREFIX + "Comment>;\n  trailingComments?: Array<" + NODE_PREFIX + "Comment>;\n  start: ?number;\n  end: ?number;\n  loc: ?" + NODE_PREFIX + "SourceLocation;\n}\n\n";

//

var lines = [];

var _loop = function _loop(type) {
  var fields = t.NODE_FIELDS[type];

  var struct = ['type: "' + type + '";'];
  var args = [];

  Object.keys(t.NODE_FIELDS[type]).sort(function (fieldA, fieldB) {
    var indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    var indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  }).forEach(function (fieldName) {
    var field = fields[fieldName];

    var suffix = "";
    if (field.optional || field.default != null) suffix += "?";

    var typeAnnotation = "any";

    var validate = field.validate;
    if (validate) {
      typeAnnotation = stringifyValidator(validate, NODE_PREFIX);
    }

    if (typeAnnotation) {
      suffix += ": " + typeAnnotation;
    }

    args.push(t.toBindingIdentifierName(fieldName) + suffix);

    if (t.isValidIdentifier(fieldName)) {
      struct.push(fieldName + suffix + ";");
    }
  });

  code += "declare class " + NODE_PREFIX + type + " extends " + NODE_PREFIX + " {\n  " + struct.join("\n  ").trim() + "\n}\n\n";

  // Flow chokes on super() and import() :/
  if (type !== "Super" && type !== "Import") {
    lines.push("declare function " + toFunctionName(type) + "(" + args.join(", ") + "): " + NODE_PREFIX + type + ";");
  }
};

for (var type in t.NODE_FIELDS) {
  _loop(type);
}

for (var i = 0; i < t.TYPES.length; i++) {
  var decl = "declare function is" + t.TYPES[i] + "(node: ?Object, opts?: ?Object): boolean";

  if (t.NODE_FIELDS[t.TYPES[i]]) {
    decl += " %checks (node instanceof " + NODE_PREFIX + t.TYPES[i] + ")";
  }

  lines.push(decl);
}

lines.push("declare function validate(n: BabelNode, key: string, value: mixed): void;", "declare function clone<T>(n: T): T;", "declare function cloneDeep<T>(n: T): T;", "declare function removeProperties<T>(n: T, opts: ?{}): void;", "declare function removePropertiesDeep<T>(n: T, opts: ?{}): T;", "declare type TraversalAncestors = Array<{\n    node: BabelNode,\n    key: string,\n    index?: number,\n  }>;\n  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;\n  declare type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };".replace(/(^|\n) {2}/g, "$1"),
// eslint-disable-next-line
"declare function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;");

for (var type in t.FLIPPED_ALIAS_KEYS) {
  var types = t.FLIPPED_ALIAS_KEYS[type];
  code += "type " + NODE_PREFIX + type + " = " + types.map(function (type) {
    return "" + NODE_PREFIX + type;
  }).join(" | ") + ";\n";
}

code += "\ndeclare module \"@babel/types\" {\n  " + lines.join("\n").replace(/\n/g, "\n  ").trim() + "\n}\n";

//

process.stdout.write(code);