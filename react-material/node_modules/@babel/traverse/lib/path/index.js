"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var virtualTypes = _interopRequireWildcard(require("./lib/virtual-types"));

function _debug() {
  var data = _interopRequireDefault(require("debug"));

  _debug = function _debug() {
    return data;
  };

  return data;
}

var _index = _interopRequireDefault(require("../index"));

var _scope = _interopRequireDefault(require("../scope"));

function t() {
  var data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

var _cache = require("../cache");

function _generator() {
  var data = _interopRequireDefault(require("@babel/generator"));

  _generator = function _generator() {
    return data;
  };

  return data;
}

var NodePath_ancestry = _interopRequireWildcard(require("./ancestry"));

var NodePath_inference = _interopRequireWildcard(require("./inference"));

var NodePath_replacement = _interopRequireWildcard(require("./replacement"));

var NodePath_evaluation = _interopRequireWildcard(require("./evaluation"));

var NodePath_conversion = _interopRequireWildcard(require("./conversion"));

var NodePath_introspection = _interopRequireWildcard(require("./introspection"));

var NodePath_context = _interopRequireWildcard(require("./context"));

var NodePath_removal = _interopRequireWildcard(require("./removal"));

var NodePath_modification = _interopRequireWildcard(require("./modification"));

var NodePath_family = _interopRequireWildcard(require("./family"));

var NodePath_comments = _interopRequireWildcard(require("./comments"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

var _debug2 = (0, _debug().default)("babel");

var NodePath = function () {
  function NodePath(hub, parent) {
    _classCallCheck(this, NodePath);

    this.parent = parent;
    this.hub = hub;
    this.contexts = [];
    this.data = {};
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed = false;
    this.state = null;
    this.opts = null;
    this.skipKeys = null;
    this.parentPath = null;
    this.context = null;
    this.container = null;
    this.listKey = null;
    this.inList = false;
    this.parentKey = null;
    this.key = null;
    this.node = null;
    this.scope = null;
    this.type = null;
    this.typeAnnotation = null;
  }

  _createClass(NodePath, [{
    key: "getScope",
    value: function getScope(scope) {
      return this.isScope() ? new _scope.default(this) : scope;
    }
  }, {
    key: "setData",
    value: function setData(key, val) {
      return this.data[key] = val;
    }
  }, {
    key: "getData",
    value: function getData(key, def) {
      var val = this.data[key];
      if (!val && def) val = this.data[key] = def;
      return val;
    }
  }, {
    key: "buildCodeFrameError",
    value: function buildCodeFrameError(msg) {
      var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;

      return this.hub.buildError(this.node, msg, Error);
    }
  }, {
    key: "traverse",
    value: function traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }
  }, {
    key: "set",
    value: function set(key, node) {
      t().validate(this.node, key, node);
      this.node[key] = node;
    }
  }, {
    key: "getPathLocation",
    value: function getPathLocation() {
      var parts = [];
      var path = this;

      do {
        var key = path.key;
        if (path.inList) key = path.listKey + "[" + key + "]";
        parts.unshift(key);
      } while (path = path.parentPath);

      return parts.join(".");
    }
  }, {
    key: "debug",
    value: function debug(message) {
      if (!_debug2.enabled) return;
      _debug2(this.getPathLocation() + " " + this.type + ": " + message);
    }
  }, {
    key: "toString",
    value: function toString() {
      return (0, _generator().default)(this.node).code;
    }
  }], [{
    key: "get",
    value: function get(_ref) {
      var hub = _ref.hub,
          parentPath = _ref.parentPath,
          parent = _ref.parent,
          container = _ref.container,
          listKey = _ref.listKey,
          key = _ref.key;

      if (!hub && parentPath) {
        hub = parentPath.hub;
      }

      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }

      var targetNode = container[key];
      var paths = _cache.path.get(parent) || [];

      if (!_cache.path.has(parent)) {
        _cache.path.set(parent, paths);
      }

      var path = void 0;

      for (var i = 0; i < paths.length; i++) {
        var pathCheck = paths[i];

        if (pathCheck.node === targetNode) {
          path = pathCheck;
          break;
        }
      }

      if (!path) {
        path = new NodePath(hub, parent);
        paths.push(path);
      }

      path.setup(parentPath, container, listKey, key);
      return path;
    }
  }]);

  return NodePath;
}();

exports.default = NodePath;
Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  var _loop2 = function _loop2() {
    var type = _step.value;

    var typeKey = "is" + type;
    var fn = t()[typeKey];

    NodePath.prototype[typeKey] = function (opts) {
      return fn(this.node, opts);
    };

    NodePath.prototype["assert" + type] = function (opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError("Expected node path of type " + type);
      }
    };
  };

  for (var _iterator = t().TYPES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    _loop2();
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

var _loop = function _loop(type) {
  if (type[0] === "_") return "continue";
  if (t().TYPES.indexOf(type) < 0) t().TYPES.push(type);
  var virtualType = virtualTypes[type];

  NodePath.prototype["is" + type] = function (opts) {
    return virtualType.checkPath(this, opts);
  };
};

for (var type in virtualTypes) {
  var _ret = _loop(type);

  if (_ret === "continue") continue;
}